// Code generated by MockGen. DO NOT EDIT.
// Source: src/domain/repositories/audit.go

// Package mock_repositories is a generated GoMock package.
package mock_repositories

import (
	context "context"
	reflect "reflect"

	models "w3st/domain/models"
	errors "w3st/errors"

	gomock "github.com/golang/mock/gomock"
)

// MockAuditRepository is a mock of AuditRepository interface.
type MockAuditRepository struct {
	ctrl     *gomock.Controller
	recorder *MockAuditRepositoryMockRecorder
}

// MockAuditRepositoryMockRecorder is the mock recorder for MockAuditRepository.
type MockAuditRepositoryMockRecorder struct {
	mock *MockAuditRepository
}

// NewMockAuditRepository creates a new mock instance.
func NewMockAuditRepository(ctrl *gomock.Controller) *MockAuditRepository {
	mock := &MockAuditRepository{ctrl: ctrl}
	mock.recorder = &MockAuditRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuditRepository) EXPECT() *MockAuditRepositoryMockRecorder {
	return m.recorder
}

// Create mocks base method.
func (m *MockAuditRepository) Create(ctx context.Context, log *models.AuditLog) *errors.DomainError {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, log)
	ret0, _ := ret[0].(*errors.DomainError)
	return ret0
}

// Create indicates an expected call of Create.
func (mr *MockAuditRepositoryMockRecorder) Create(ctx, log interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockAuditRepository)(nil).Create), ctx, log)
}

// FindAll mocks base method.
func (m *MockAuditRepository) FindAll(ctx context.Context, limit, offset int) ([]*models.AuditLog, *errors.DomainError) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindAll", ctx, limit, offset)
	ret0, _ := ret[0].([]*models.AuditLog)
	ret1, _ := ret[1].(*errors.DomainError)
	return ret0, ret1
}

// FindAll indicates an expected call of FindAll.
func (mr *MockAuditRepositoryMockRecorder) FindAll(ctx, limit, offset interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAll", reflect.TypeOf((*MockAuditRepository)(nil).FindAll), ctx, limit, offset)
}

// FindByAction mocks base method.
func (m *MockAuditRepository) FindByAction(ctx context.Context, action string) ([]*models.AuditLog, *errors.DomainError) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByAction", ctx, action)
	ret0, _ := ret[0].([]*models.AuditLog)
	ret1, _ := ret[1].(*errors.DomainError)
	return ret0, ret1
}

// FindByAction indicates an expected call of FindByAction.
func (mr *MockAuditRepositoryMockRecorder) FindByAction(ctx, action interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByAction", reflect.TypeOf((*MockAuditRepository)(nil).FindByAction), ctx, action)
}

// FindByID mocks base method.
func (m *MockAuditRepository) FindByID(ctx context.Context, id string) (*models.AuditLog, *errors.DomainError) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByID", ctx, id)
	ret0, _ := ret[0].(*models.AuditLog)
	ret1, _ := ret[1].(*errors.DomainError)
	return ret0, ret1
}

// FindByID indicates an expected call of FindByID.
func (mr *MockAuditRepositoryMockRecorder) FindByID(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockAuditRepository)(nil).FindByID), ctx, id)
}

// FindByProjectID mocks base method.
func (m *MockAuditRepository) FindByProjectID(ctx context.Context, projectID int) ([]*models.AuditLog, *errors.DomainError) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByProjectID", ctx, projectID)
	ret0, _ := ret[0].([]*models.AuditLog)
	ret1, _ := ret[1].(*errors.DomainError)
	return ret0, ret1
}

// FindByProjectID indicates an expected call of FindByProjectID.
func (mr *MockAuditRepositoryMockRecorder) FindByProjectID(ctx, projectID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByProjectID", reflect.TypeOf((*MockAuditRepository)(nil).FindByProjectID), ctx, projectID)
}

// FindByProjectIDWithLimit mocks base method.
func (m *MockAuditRepository) FindByProjectIDWithLimit(ctx context.Context, projectID, limit, offset int) ([]*models.AuditLog, *errors.DomainError) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByProjectIDWithLimit", ctx, projectID, limit, offset)
	ret0, _ := ret[0].([]*models.AuditLog)
	ret1, _ := ret[1].(*errors.DomainError)
	return ret0, ret1
}

// FindByProjectIDWithLimit indicates an expected call of FindByProjectIDWithLimit.
func (mr *MockAuditRepositoryMockRecorder) FindByProjectIDWithLimit(ctx, projectID, limit, offset interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByProjectIDWithLimit", reflect.TypeOf((*MockAuditRepository)(nil).FindByProjectIDWithLimit), ctx, projectID, limit, offset)
}

// FindByUserID mocks base method.
func (m *MockAuditRepository) FindByUserID(ctx context.Context, userID string) ([]*models.AuditLog, *errors.DomainError) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByUserID", ctx, userID)
	ret0, _ := ret[0].([]*models.AuditLog)
	ret1, _ := ret[1].(*errors.DomainError)
	return ret0, ret1
}

// FindByUserID indicates an expected call of FindByUserID.
func (mr *MockAuditRepositoryMockRecorder) FindByUserID(ctx, userID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByUserID", reflect.TypeOf((*MockAuditRepository)(nil).FindByUserID), ctx, userID)
}
